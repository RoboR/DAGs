The code under the path dag_generator is based on the work of https://github.com/Nan-Do/dag_generator
which generates random directed acyclic graphs (DAG)

Additional functionality is added to the availble code which are:
- Adding multiple node cost matrix for multi-core support, this is specified with the argument --processor
- Range of the node cost is assignned randomly within the range specified by --min-node-cost and --max-node-cost
- Edges of the graphs, or Links in over here, is added with a value which represents the communication cost, specified by --min-link-cost and --max-link-cost
- A root node and an ending node is added to each DAG graph generated to have a single point of entry and a single point of exit
- Addtional information for lowerbound and deadline is added to allow reading and writting to file
- Main application (main.py) is modified as a Class GraphGenerator.py


Python version to work with is Python 2.7 for all python files in this directory. 
PyCharm is the IDE the author is using, additional libraries are from python standard library.

Author: YZ Lim


DAG graph can be generated by either using the command line interface (CLI) or creating an instance of class GraphGenerator.

CLI method:
python GraphGenerator.py --store-graph --output-directory output --depth 3 --dead-line 50 --min-node-cost 10 --max-node-cost 100 --min-link-cost 5 --max-link-cost 50 --outdegree 3 --processor 10 --size 10 

Calling GraphGenerator Class:
In python file import the class 
"from GraphGenerator import GraphGenerator"

Create a GraphGenerator instance and store the DAG graph
graph_arg = GraphGenerator.GraphArgs(add=None, dag='none', dead_line=DEADLINE, delete=None, depth=depth,
                                     dot=False, load_graph=load_graph,
                                     max_link_cost=comm_max, max_node_cost=TASK_COST_MAX,
                                     min_link_cost=comm_min, min_node_cost=TASK_COST_MIN,
                                     outdegree=outdegree, output_directory=outdir,
                                     processor=PROCESSOR_NUMBER, redundancy=None, relabel=None,
                                     reorder=None, size=task_size, spine=None, store_graph=store_graph,
                                     summary=False, swap_links=None, swap_nodes=None, upper=False)
graph_generator = GraphGenerator()
graph_generator.set_arguments(graph_arg)
output_directory = "./output"
graph_generator.store_dag(output_directory)

Result:
A dag file representation <random_id>-representation.dag
A python graph file graph-<random_id>.py




DAG class
To extend the functionality of the graph class, a DAG class is created which inherited from the graph class. The additional functionalities are
- Traverse of graph to find the successor and predecessor nodes/tasks
- Calculating of rankU value
- Calculating the lowerbound value
- Setting priority and deadline values
- Minimum Earliest Finish Time (EFT) insertion policy
- The above functionality are support for multiple cores and the core numbers can be changed dynamically


MHEFT.py
This file contains three classes:
FMHEFT - Fairness on multiple HEFT algorithm
WPHEFT - Work priority on multiple HEFT algorithm
PPHEFT - Partial priority on multiple HEFT algorithm

Each class is a task scheduler algorithm proposed under the paper
[G. Xie, G. Zeng, L. Liu, R. Li and K.Li, "Mixed real-time scheduling of multiple DAGs-based applications on
heterogeneous multi-core processors," Microprocessors and Microsystems, vol. 47, pp. 93-103, 2016.]

To use it to schedule DAGs applications, the steps needed are:
1) Creating DAG application, DAG class, this can be loaded from a file
   DAG_1 = DAG(task_1_config)
2) Set prioties of DAG application
   DAG_1.set_application_priority(1)
3) Add the DAG application to the scheduler
   f_mheft = FMHEFT(3) # 3 processor are used
   f_mheft.add_application()
4) Find the task scheduling result
   f_mheft.find_makespan()
5) Get total makespan and task allocation result
   print(f_mheft.makespan)
   print(f_mheft.task_allocation_queue)

An example of using all three scheduler can be found under the main function of MHEFT.py. The DAG application are taken exactly from the paper examples.



Simulation.py
This python file is used for generating data and running analyze on the data.
def generate_data() takes in the constant parameters defined and calls GraphGenerator to output DAG application graphs
def get_fat_index() is used to sort the DAG graph with fat index (graph width / graph height)
def check_task_depth_outdegree_is_valid() is used to check the graph has a valid depth before actual creation to avoid run time error

def analyze_data() will reads DAG application from the previous generated outputs and sets the parameters configuration with the combination stated in the Constant header section. It will run with the same inputs and compare the performance on the three schedulerm F_MHEFT, WP_MHEFT, and PP_MHEFT.
The result is output to a text file, a sample can be seen as below:

comm ratio: comm_ratio_20 ; FAT ratio: fat_1.0 ; applications no: 5 ; processor no: 2 ; deadline ratio : 5
F_MHEFT
Applications : 5
app: cw0K; app priority: 1; nodes: 19; lowerbound: 504; deadline: 604; makespan: 2504; lateness: 3.1457
app: g5ah; app priority: 2; nodes: 24; lowerbound: 630; deadline: 756; makespan: 2882; lateness: 2.8122
app: HrGy; app priority: 3; nodes: 27; lowerbound: 678; deadline: 813; makespan: 3026; lateness: 2.722
app: WzWR; app priority: 4; nodes: 28; lowerbound: 774; deadline: 928; makespan: 3071; lateness: 2.3093
app: BUfB; app priority: 5; nodes: 39; lowerbound: 1020; deadline: 1224; makespan: 3197; lateness: 1.6119
DMRs: 1.0; overall lateness: 12.6011; total makespan: 3197
WP_MHEFT
Applications : 5
app: cw0K; app priority: 1; nodes: 19; lowerbound: 504; deadline: 604; makespan: 504; lateness: -0.1656
app: g5ah; app priority: 2; nodes: 24; lowerbound: 630; deadline: 756; makespan: 1029; lateness: 0.3611
app: HrGy; app priority: 3; nodes: 27; lowerbound: 678; deadline: 813; makespan: 1639; lateness: 1.016
app: WzWR; app priority: 4; nodes: 28; lowerbound: 774; deadline: 928; makespan: 2388; lateness: 1.5733
app: BUfB; app priority: 5; nodes: 39; lowerbound: 1020; deadline: 1224; makespan: 3392; lateness: 1.7712
DMRs: 0.8; overall lateness: 4.556; total makespan: 3392
PP_MHEFT
Applications : 5
app: cw0K; app priority: 1; nodes: 19; lowerbound: 504; deadline: 604; makespan: 533; lateness: -0.1175
app: g5ah; app priority: 2; nodes: 24; lowerbound: 630; deadline: 756; makespan: 1075; lateness: 0.422
app: HrGy; app priority: 3; nodes: 27; lowerbound: 678; deadline: 813; makespan: 1590; lateness: 0.9557
app: WzWR; app priority: 4; nodes: 28; lowerbound: 774; deadline: 928; makespan: 2339; lateness: 1.5205
app: BUfB; app priority: 5; nodes: 39; lowerbound: 1020; deadline: 1224; makespan: 3343; lateness: 1.7312
DMRs: 0.8; overall lateness: 4.5119; total makespan: 3343


